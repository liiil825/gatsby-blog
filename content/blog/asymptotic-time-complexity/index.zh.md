---
title: O(kn) === O(n)?
date: "2021-01-18T11:10:32.169Z"
description: 时间复杂度中，为什么可以抛弃前面的系数是算法初学者中，会面临到的第一个奇怪的地方，我也是最近才有新的体会
---

学习算法，离不开算法时间复杂度分析。但我敢说这个问题不到一半的人真正想明白。但当你明白这个问题后你会对你该写什么样的代码有新的认识。

### 大 O 复杂度表示法

大 O 时间复杂度表示法。表示代码执行时间随数据规模 *增长的变化趋势* ，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
关键就在这增长的变化趋势，表示的是增长的增长。

### O(kn) === O(n)

为什么能简化掉前面的系数。简单的说，增长的变化趋势类似看是求导。而常数的导数是 0。这个说法有点抽象。举个直观的例子：

1. 假如系数 k 等于 1000，当数据量也等于 n 为 1000 时。
此时, `k:n = 1:1` ，此时 `O(kn) === 2 * O(n)`
2. 当数据量增长到 10000 时。
此时, `k:n = 1:10` ，此时 `O(kn) === 1.1 * O(n)`
3. 当数据量增长到 1000000 时。
此时, `k:n = 1:1000` ，此时 `O(kn) === 1.001 * O(n)`
4. 观察发现，系数不管多大，但它是个常量，也许开头影响很大，但它不会变化。就是说它对 *增长的变化趋势* 没有影响，而 n 是个可能会增到到无限的数。所以 `O(kn) === O(n)`

### 算法时间复杂度不等于算法的执行速度

大 O 时间复杂度实际上并不具体表示代码真正的执行时间。从执行时间来看，O(kn) 肯定是比 O(n) 要慢的，但为什么算法复杂度分析是描述 *增长的变化趋势* ？

1. 没有办法能准确表示一段代码具体的执行时间。因为每行代码执行时间不是相同的。

2. 绝大部分情况是不需要一个能表示具体表示执行效率的方法。

在 leetcode 上写过算法题就会发现，相同的代码多提交几次，执行时间也是变化很大的，那么你一段代码比另一端明显好一点，也无法确保你的执行时间会少。所以当算法时间复杂度无法提高就足够了，没必要执着于把 `O(kn)` 再优化到 `O(n)`

3. 具体情况具体分析，当然在写算法题时，你能写 `O(n)` 就没必要写 `O(kn)`，但具体开发中，比起 `O(n)`，更应该注意的是你的代码可读性。
